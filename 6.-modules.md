
# 6. Mô-đun

Nếu bạn thoát khỏi trình thông dịch Python và quay lại nó, các định nghĩa bạn đã thực hiện \ (hàm và biến \) lúc trước sẽ bị mất. Do đó, nếu bạn muốn viết chương trình dài hơn, bạn nên sử dụng trình soạn thảo văn bản để chuẩn bị đầu vào cho trình thông dịch và chạy nó với đầu vào là file đã được tạo. Việc này được gọi là tạo một _script_. Khi chương trình của bạn còn dài hơn nữa, bạn có thể chia nó thành nhiều file để bảo trì dễ dàng hơn. Bạn cũng có thể sử dụng một hàm hay dùng mà bạn đã viết trong nhiều chương trình mà không cần sao chép định nghĩa của nó vào từng chương trình.

Để hỗ trợ điều này, Python có cách để đưa các định nghĩa vào một file và sử dụng chúng trong một file script hoặc trong một phiên tương tác với trình thông dịch. Một file như vậy được gọi là _module_; các định nghĩa từ một mô-đun có thể được _imported_ vào các mô-đun khác hoặc vào mô-đun _main_ \ (tập hợp các biến mà bạn có quyền truy cập trong một script được thực thi ở cấp cao nhất - mức ngoài cùng và ở chế độ máy tính ???\).

Một mô-đun là một file chứa các định nghĩa và câu lệnh Python. Tên file là tên mô-đun có thêm hậu tố `.py`. Trong mô-đun, tên của mô-đun \ (dưới dạng chuỗi \) được lưu sẵn trong giá trị của biến toàn cục`__name__`. Ví dụ, sử dụng trình soạn thảo văn bản yêu thích của bạn để tạo một file có tên là `fibo.py` trong thư mục hiện tại với các nội dung sau:

`` `text
# Mô-đun số Fibonacci

def fib (n): # viết chuỗi Fibonacci lên đến n
    a, b = 0, 1
    while b < n:
        print(b, end=' ')
        a, b = b, a + b
    print()

def fib2 (n): # trả về dãy Fibonacci đến n
    result = []
    a, b = 0, 1
    while b < n:
        result.append (b)
        a, b = b, a + b
    return result
`` `

Bây giờ vào trình thông dịch Python và import mô-đun này bằng lệnh sau: & gt; & gt; & gt;

```text
>>> import fibo
`` `

Chỗ này không đưa tên của các hàm được định nghĩa trong `fibo` trực tiếp vào trong bảng ký hiệu hiện tại; nó chỉ đưa tên mô-đun 'fibo` thôi. Sau đó sử dụng tên mô-đun, bạn có thể truy cập các hàm: & gt; & gt; & gt;

```text
>>> fibo.fib (1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib2 (100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
>>> fibo .__ name__
'fibo'
`` `

Nếu bạn định sử dụng hàm thường xuyên, bạn có thể gán nó cho một tên cục bộ: & gt; & gt; & gt;

```text
>>> fib = fibo.fib
>>> fib (500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
`` `

### 6.1. Thông tin thêm về Mô-đun

Một mô-đun có thể chứa các câu lệnh thực thi cũng như các định nghĩa hàm. Các câu lệnh này dùng để khởi tạo mô-đun. Chúng được chạy chỉ trong lần đầu tiên (_first_) khi tên mô-đun được xuất hiện trong một câu lệnh import. [\ [1 \]] (https://docs.python.org/3/tutorial/modules.html#id2) \ (Chúng cũng được chạy nếu file module được thực thi dưới dạng tập script.\)

Mỗi mô-đun có bảng kí hiệu (hàm, biến, ..etc - symbol) riêng của nó, được sử dụng làm bảng kí hiệu toàn cục toàn cục cho tất cả các hàm được định nghĩa trong mô-đun. Do đó, tác giả của một mô-đun có thể sử dụng các biến toàn cục trong mô-đun mà không phải lo lắng về các xung đột tình cờ với các biến toàn cục của người dùng sử dụng mô-đun. Mặt khác, nếu bạn đã biết rõ về module đó, bạn có thể truy cập vào các biến toàn cục của một mô-đun, như cách bạn tham chiếu đến các hàm của nó, `modname.itemname`.

Mô-đun còn có thể import các mô-đun khác. Có một thói quen nhưng không bắt buộc, đó là đặt tất cả câu lệnh [`import`] (https://docs.python.org/3/reference/simple_stmts.html#import) ở đầu mô-đun \ (hoặc script, hoặc tương tự \). Các tên mô-đun đã import được đặt trong bảng ký hiệu toàn cục của mô-đun đang được import vào.

Có một biến thể của câu lệnh [`import`] (https://docs.python.org/3/reference/simple_stmts.html#import) để nhập tên từ mô-đun trực tiếp vào bảng biểu tượng của mô-đun import. Ví dụ: & gt; & gt; & gt;

```text
>>> from fibo import fib, fib2
>>> fib (500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
`` `

Cách này không đưa tên mô-đun vào những thứ được import vào bảng symbol cục bộ \ (ví dụ, trong ví dụ, `fibo` không được sẽ không được thêm vào bảng \).

Thậm chí còn có một biến thể để import tất cả các tên mà mô-đun đã định nghĩa nữa: & gt; & gt; & gt;

`` `text
>>> from fibo import *
>>> fib (500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
`` `

Đoạn này sẽ nhập tất cả các định nghĩa trừ các tên bắt đầu bằng dấu gạch dưới \ (`_` \). Trong hầu hết các trường hợp, các lập trình viên Python không sử dụng cách này vì nó sẽ đưa một số tên không được hiểu rõ vào trình thông dịch, dẫn đến có nguy cơ một số tên trùng bị ghi đè giá trị hay mất giá trị được gán lúc trước.

Lưu ý rằng nói chung, việc import sử dụng `*` từ một mô-đun hoặc gói được không được khuyến khích, vì nó làm cho code trở nên khó đọc. Tuy nhiên, bạn có thể sử dụng nó để đỡ phải gõ nhiều khi làm việc ở chế độ tương tác.

Nếu tên mô-đun được theo sau bởi [`as`] (https://docs.python.org/3/reference/compound_stmts.html#as), thì tên phía sau [` as`] (https: // docs. python.org/3/reference/compound_stmts.html#as) được liên kết trực tiếp với mô-đun đã nhập. & gt; & gt; & gt;

`` `text
>>> import fibo như fib
>>> fib.fib (500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
`` `

Điều này là để import các mô-đun như cách mà `import fibo` làm, chỉ có sự khác biệt duy nhất giờ có một cái tên là ` fib` được định nghĩa thôi.

Nó cũng có thể dùng được khi sử dụng [`from`] (https://docs.python.org/3/reference/simple_stmts.html#from) với các tác dụng tương tự: & gt; & gt; & gt;

`` `text
>>> từ fibo import fib là fibonacci
>>> fibonacci (500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
`` `

Chú thích 

Vì lý liên quan đến tính hiệu quả, mỗi mô-đun chỉ được import một lần cho mỗi phiên làm việc với thông dịch. Do đó, nếu bạn thay đổi mô-đun, bạn phải khởi động lại trình thông dịch - hoặc, nếu nó là một mô-đun bạn muốn kiểm tra ngay trong lúc tương tác, hãy sử dụng [`importlib.reload ()`] (https://docs.python.org/3/ library / importlib.html # importlib.reload), ví dụ: `import importlib; importlib.reload (modulename) `.

#### 6.1.1. Thực thi các mô-đun dưới dạng scripts

Khi bạn chạy một mô-đun Python với

`` `text
python fibo.py <arguments>
`` `

code trong mô-đun sẽ được thực hiện, sẽ giống như khi bạn import nó, nhưng với giá trị `__name__` được gán là ` "__main __" `. Điều đó có nghĩa là bằng cách thêm mã này vào cuối mô-đun của bạn:

`` `text
nếu __name__ == "__main__":
    import sys
    fib (int (sys.argv [1]))
`` `

bạn có thể làm cho file vừa có thể được sử dụng làm script cũng vừa là một mô-đun, bởi vì code cái đọc giá trị từ dòng lệnh chỉ chạy nếu mô-đun được thực thi dưới dạng file "main":

`` `text
$ python fibo.py 50
1 1 2 3 5 8 13 21 34
`` `

Nếu mô-đun được import, thì code sẽ không chạy: & gt; & gt; & gt;

`` `text
>>> import fibo
>>>
`` `

Điều này thường được sử dụng cho việc hoặc là cung cấp một giao diện người dùng thuận tiện cho một mô-đun, hoặc cho mục đích kiểm thử \ (chạy mô-đun như một scrip thực hiện một loạt test case \).

#### 6.1.2. Đường dẫn tìm kiếm mô-đun

Khi một mô-đun có tên là `spam` được import, đầu tiên trình thông dịch tìm kiếm trong các mô-đun nó được tích hợp sẵn xem có tên đó không. Nếu không tìm thấy, nó sẽ tìm kiếm một file có tên `spam.py` trong một danh sách các thư mục được đưa ra bởi biến [` sys.path`] (https://docs.python.org/3/library/sys.html # sys.path). [`sys.path`] (https://docs.python.org/3/library/sys.html#sys.path) được khởi tạo từ các vị trí sau:

* Thư mục chứa tập script đầu vào \ (hoặc thư mục hiện tại khi không có file nào được chỉ định \).
* [`PYTHONPATH`] (https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH) \ (danh sách các tên thư mục, có cùng cùng cú pháp với biến shell` PATH` \) .
* Mặc định được gán lúc cài đặt.

Chú thích 

Trên các hệ thống file hỗ trợ các liên kết tượng trưng (liên kết mềm, symlinks), ​​thư mục chứa script đầu vào được sau khi liên kết được truy ra. Nói cách khác, thư mục chứa liên kết tượng trưng ** không ** được thêm vào đường dẫn tìm kiếm mô-đun.

Sau khi khởi tạo, các chương trình Python có thể sửa đổi [`sys.path`] (https://docs.python.org/3/library/sys.html#sys.path). Thư mục chứa tập lệnh đang chạy được đặt ở đầu đường dẫn tìm kiếm, phía trước đường dẫn thư viện chuẩn. Điều này có nghĩa là các tập lệnh trong thư mục đó sẽ được load vào, chứ không phải mô-đun cùng tên trong thư mục thư viện. Đây là lỗi trừ khi thay thế được dự định. Xem phần [Mô-đun Chuẩn] (https://docs.python.org/3/tutorial/modules.html#tut-standardmodules) để biết thêm thông tin.

#### 6.1.3. Các file Python được "biên dịch"

Để tăng tốc độ tải các mô-đun, Python lưu trữ (caches) một bản đã được biên dịch của từng mô-đun trong thư mục `__pycache__` dưới tên` module.`_`version`_`.pyc`, trong đó "version" sẽ là định dạng của file được biên dịch; nó cũng thường chứa số phiên bản Python nữa. Ví dụ, trong CPython 3.3, phiên bản được biên dịch của spam.py sẽ được lưu trữ dưới dạng `__pycache __ / spam.cpython-33.pyc`. Quy ước đặt tên này cho phép các mô-đun được biên dịch từ các bản phát hành khác nhau và các phiên bản Python khác nhau cùng tồn tại.

Python kiểm tra ngày sửa đổi của nguồn so với phiên bản đã biên dịch để xem nó có bị cũ và cần được biên dịch lại hay không. Đây là một quá trình hoàn toàn tự động. Ngoài ra, các mô đun được biên dịch là độc lập với nền tảng, do đó cùng một thư viện có thể được chia sẻ giữa các hệ thống với các kiến ​​trúc khác nhau.

Python không kiểm tra cache trong hai trường hợp. Đầu tiên, nó luôn biên dịch lại và không lưu trữ kết quả cho mô đun được tải trực tiếp từ dòng lệnh. Thứ hai, nó không kiểm tra cache nếu không có module nguồn. Để hỗ trợ phân phối không nguồn \ (chỉ biên dịch \), mô đun được biên dịch phải nằm trong thư mục nguồn và không phải là một mô-đun nguồn.

Một số mẹo cho các chuyên gia:

* Bạn có thể sử dụng [`-O`] (https://docs.python.org/3/using/cmdline.html#cmdoption-o) hoặc [` -OO`] (https: //docs.python. org / 3 / using / cmdline.html # cmdoption-oo) chuyển đổi trên lệnh Python để giảm kích thước của một mô-đun được biên dịch. Nút `-O` loại bỏ các câu lệnh khẳng định, công tắc` -OO` loại bỏ cả hai câu lệnh khẳng định và \ _ \ _ doc \ _ \ _. Vì một số chương trình có thể dựa vào những tính năng này, bạn chỉ nên sử dụng tùy chọn này nếu bạn biết mình đang làm gì. Mô-đun "Tối ưu hóa" có thẻ `opt-` và thường nhỏ hơn. Các bản phát hành trong tương lai có thể thay đổi tác động của tối ưu hóa.
* Chương trình không chạy nhanh hơn khi đọc từ tập tin `.pyc` hơn khi đọc từ tập tin` .py`; điều duy nhất nhanh hơn về các file `.pyc` là tốc độ tải chúng.
* Module [`compileall`] (https://docs.python.org/3/library/compileall.html#module-compileall) có thể tạo các file .pyc cho tất cả các mô-đun trong một thư mục.
* Có thêm chi tiết về quy trình này, bao gồm biểu đồ lưu lượng của các quyết định, trong PEP 3147.

### 6.2. Mô-đun chuẩn

Python đi kèm với một thư viện các mô-đun chuẩn, được mô tả trong một tài liệu riêng biệt, Tham khảo Thư viện Python \ ("Tham khảo Thư viện" sau đây \). Một số mô-đun được tích hợp vào trình thông dịch; chúng cung cấp quyền truy cập vào các hoạt động không phải là một phần cốt lõi của ngôn ngữ nhưng vẫn được tích hợp sẵn, hoặc để có hiệu quả hoặc cung cấp quyền truy cập vào các nguyên bản của hệ điều hành như các cuộc gọi hệ thống. Tập hợp các mô-đun như vậy là một tùy chọn cấu hình cũng phụ thuộc vào nền tảng cơ bản. Ví dụ, mô-đun [`winreg`] (https://docs.python.org/3/library/winreg.html#module-winreg) chỉ được cung cấp trên các hệ thống Windows. Một mô-đun đặc biệt đáng chú ý: [`sys`] (https://docs.python.org/3/library/sys.html#module-sys), được xây dựng trong mọi trình thông dịch Python. Các biến `sys.ps1` và` sys.ps2` xác định các chuỗi được sử dụng làm lời nhắc chính và phụ: & gt; & gt; & gt;

`` `text
>>> import sys
>>> sys.ps1
'>>>'
>>> sys.ps2
'... '
>>> sys.ps1 = 'C>'
C> in ('Yuck!')
Kinh quá!
C>
`` `

Hai biến này chỉ được xác định nếu trình thông dịch ở chế độ tương tác.

Biến `sys.path` là một danh sách các chuỗi xác định đường dẫn tìm kiếm của trình thông dịch cho các mô-đun. Nó được khởi tạo cho một đường dẫn mặc định được lấy từ biến môi trường [`PYTHONPATH`] (https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH), hoặc từ một mặc định dựng sẵn nếu [ `PYTHONPATH`] (https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH) chưa được đặt. Bạn có thể sửa đổi nó bằng cách sử dụng các hoạt động danh sách chuẩn: & gt; & gt; & gt;

`` `text
>>> import sys
>>> sys.path.append ('/ ufs / guido / lib / python')
`` `

### 6.3. Hàm [`dir ()`] (https://docs.python.org/3/library/functions.html#dir) Hàm

Hàm dựng sẵn [`dir ()`] (https://docs.python.org/3/library/functions.html#dir) được sử dụng để tìm ra tên mà mô-đun xác định. Nó trả về danh sách các chuỗi được sắp xếp: & gt; & gt; & gt;

`` `text
>>> import fibo, sys
>>> dir (fibo)
['__name__', 'fib', 'fib2']
>>> dir (sys)  
['__displayhook__', '__doc__', '__excepthook__', '__loader__', '__name__',
'__package__', '__stderr__', '__stdin__', '__stdout__',
'_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe',
'_home', '_mercurial', '_xoptions', 'abiflags', 'api_version', 'argv',
'base_exec_prefix', 'base_prefix', 'builtin_module_names', 'byteorder',
'call_tracing', 'callstats', 'copyright', 'displayhook',
'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix',
'thực thi', 'thoát', 'cờ', 'float_info', 'float_repr_style',
'getcheckinterval', 'getdefaultencoding', 'getdlopenflags',
'getfilesystemencoding', 'getobjects', 'getprofile', 'getrecursionlimit',
'getrefcount', 'getizeof', 'getswitchinterval', 'gettotalrefcount',
'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',
'intern', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path',
'path_hooks', 'path_importer_cache', 'nền tảng', 'tiền tố', 'ps1',
'setcheckinterval', 'setdlopenflags', 'setprofile', 'setrecursionlimit',
'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout',
'thread_info', 'version', 'version_info', 'warnoptions']
`` `

Không có đối số, [`dir ()`] (https://docs.python.org/3/library/functions.html#dir) liệt kê các tên bạn đã xác định hiện tại: & gt; & gt; & gt;

`` `text
>>> a = [1, 2, 3, 4, 5]
>>> import fibo
>>> fib = fibo.fib
>>> dir ()
['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']
`` `

Lưu ý rằng nó liệt kê tất cả các loại tên: biến, mô-đun, chức năng, v.v.

[`dir ()`] (https://docs.python.org/3/library/functions.html#dir) không liệt kê tên của các hàm và biến tích hợp sẵn. Nếu bạn muốn một danh sách, chúng được định nghĩa trong mô-đun chuẩn [`builtins`] (https://docs.python.org/3/library/builtins.html#module-builtins): & gt; & gt; & gt;

`` `text
>>> nhập nội trang
>>> dir (nội trang)  
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',
'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',
'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',
'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',
'EOFError', 'Dấu ba chấm', 'EnvironmentError', 'Ngoại lệ', 'Sai',
'FileExistsError', 'FileNotFoundError', 'FloatingPointError',
'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',
'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',
'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',
'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',
'NotImplementedError', 'OSError', 'OverflowError',
'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',
'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',
'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',
'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',
'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',
'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',
'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',
'__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',
'tất cả', 'bất kỳ', 'ascii', 'bin', 'bool', 'bytearray', 'byte', 'có thể gọi',
'chr', 'classmethod', 'biên dịch', 'phức tạp', 'bản quyền', 'tín dụng',
'delattr', 'dict', 'dir', 'divmod', 'liệt kê', 'eval', 'exec', 'thoát',
'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',
'băm', 'trợ giúp', 'hex', 'id', 'đầu vào', 'int', 'isinstance', 'issubclass',
'lặp lại', 'len', 'giấy phép', 'danh sách', 'người dân địa phương', 'bản đồ', 'tối đa', 'bộ nhớ',
'phút', 'tiếp theo', 'đối tượng', 'oct', 'mở', 'ord', 'pow', 'print', 'property',
'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',
'được sắp xếp', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',
'zip']
`` `

### 6.4. Gói

Các gói là một cách để cấu trúc không gian tên mô-đun của Python bằng cách sử dụng "tên mô-đun chấm chấm". Ví dụ, tên module `AB` chỉ định một mô-đun con có tên là` B` trong một gói có tên `A`. Cũng giống như việc sử dụng các mô-đun tiết kiệm cho các tác giả của các mô-đun khác nhau phải lo lắng về tên biến toàn cục của nhau, việc sử dụng tên mô-đun chấm chấm lưu các tác giả của các gói đa mô-đun như NumPy hoặc Pillow khỏi phải lo lắng về các tên mô-đun của nhau .

Giả sử bạn muốn thiết kế một tập hợp các mô-đun \ (một "gói" \) để xử lý thống nhất các file âm thanh và dữ liệu âm thanh. Có nhiều định dạng file âm thanh khác nhau \ (thường được nhận dạng bởi phần mở rộng của chúng, ví dụ: `.wav`,` .aiff`, `.au` \), vì vậy bạn có thể cần tạo và duy trì một tập hợp các mô-đun ngày càng tăng cho chuyển đổi giữa các định dạng file khác nhau. Cũng có nhiều thao tác khác nhau mà bạn có thể muốn thực hiện trên dữ liệu âm thanh \ (chẳng hạn như trộn, thêm echo, áp dụng hàm cân bằng, tạo hiệu ứng stereo nhân tạo \), ngoài ra bạn sẽ viết luồng mô-đun không bao giờ kết thúc để thực hiện các hoạt động này. Đây là một cấu trúc có thể cho gói của bạn \ (được biểu thị bằng hệ thống file phân cấp \):

`` `text
Gói âm thanh / cấp cao nhất
      __init__.py Khởi tạo gói âm thanh
      định dạng / Gói con để chuyển đổi định dạng file
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      hiệu ứng / Subpackage cho hiệu ứng âm thanh
              __init__.py
              echo.py
              surround.py
              revers.py
              ...
      bộ lọc / Subpackage cho các bộ lọc
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
`` `

Khi nhập gói, Python tìm kiếm thông qua các thư mục trên `sys.path` để tìm thư mục con của gói.

Các file `__init __. Py` được yêu cầu để làm cho Python xử lý các thư mục có chứa các gói; điều này được thực hiện để ngăn các thư mục có tên chung, chẳng hạn như `chuỗi`, từ vô tình ẩn các mô-đun hợp lệ xảy ra sau này trên đường dẫn tìm kiếm mô-đun. Trong trường hợp đơn giản nhất, `__init __. Py` chỉ có thể là một file rỗng, nhưng nó cũng có thể thực thi mã khởi tạo cho gói hoặc đặt biến` __all__`, được mô tả sau.

Người dùng của gói có thể nhập các mô-đun riêng lẻ từ gói, ví dụ:

`` `text
import sound.effects.echo
`` `

Điều này tải submodule `sound.effects.echo`. Nó phải được tham chiếu với tên đầy đủ của nó.

`` `text
sound.effects.echo.echofilter (đầu vào, đầu ra, độ trễ = 0,7, atten = 4)
`` `

Một cách khác để nhập mô-đun con là:

`` `text
từ sound.effects import echo
`` `

Điều này cũng nạp submodule `echo`, và làm cho nó có sẵn mà không có tiền tố gói của nó, vì vậy nó có thể được sử dụng như sau:

`` `text
echo.echofilter (đầu vào, đầu ra, độ trễ = 0,7, atten = 4)
`` `

Tuy nhiên, một biến thể khác là nhập hàm hoặc biến mong muốn trực tiếp:

`` `text
từ echofilter import sound.effects.echo
`` `

Một lần nữa, điều này nạp submodule `echo`, nhưng điều này làm cho hàm của nó` echofilter () `có sẵn trực tiếp:

`` `text
echofilter (đầu vào, đầu ra, độ trễ = 0,7, atten = 4)
`` `

Lưu ý rằng khi sử dụng `từ mục nhập gói`, mục có thể là một mô-đun con (hoặc gói con \) của gói, hoặc một số tên khác được định nghĩa trong gói, như một hàm, lớp hoặc biến. Câu lệnh `import` đầu tiên kiểm tra xem mục được định nghĩa trong gói; nếu không, nó giả định nó là một mô-đun và cố gắng tải nó. Nếu nó không tìm thấy nó, một ngoại lệ [`ImportError`] (https://docs.python.org/3/library/exceptions.html#ImportError) được nâng lên.

Ngược lại, khi sử dụng cú pháp như `import item.subitem.subsubitem`, mỗi mục ngoại trừ mục cuối cùng phải là một gói; mục cuối cùng có thể là một mô-đun hoặc một gói nhưng không thể là một lớp hoặc hàm hoặc biến được xác định trong mục trước đó.

#### 6.4.1. Nhập \ * Từ gói

Bây giờ điều gì sẽ xảy ra khi người dùng viết `từ sound.effects import *`? Lý tưởng nhất, người ta sẽ hy vọng rằng điều này bằng cách nào đó đi ra ngoài hệ thống tập tin, tìm thấy submodules có mặt trong gói, và import tất cả. Quá trình này có thể mất nhiều thời gian và việc nhập các mô-đun phụ có thể có các tác dụng phụ không mong muốn chỉ xảy ra khi mô đun phụ được nhập một cách rõ ràng.

Giải pháp duy nhất là dành cho tác giả gói để cung cấp chỉ mục rõ ràng về gói. Câu lệnh [`import`] (https://docs.python.org/3/reference/simple_stmts.html#import) sử dụng quy ước sau đây: nếu mã` __init __. Py` của một gói định nghĩa một danh sách có tên `__all__`, nó được lấy là danh sách các tên mô-đun cần được nhập khi `từ gói nhập * * gặp phải. Tùy thuộc vào tác giả gói để cập nhật danh sách này khi phiên bản mới của gói được phát hành. Tác giả gói cũng có thể quyết định không hỗ trợ nó, nếu họ không thấy sử dụng để nhập \ * từ gói của họ. Ví dụ, file `sound / effects / __ init __. Py` có thể chứa đoạn mã sau:

`` `text
__all__ = ["echo", "surround", "reverse"]
`` `

Điều này có nghĩa là `from sound.effects import *` sẽ nhập ba tên con được đặt tên là `sound`package.

Nếu `__all__` không được định nghĩa, câu lệnh` from sound.effects import * `hiện _not_ import tất cả các submodules từ gói` sound.effects` vào không gian tên hiện tại; nó chỉ đảm bảo rằng gói `sound.effects` đã được nhập \ (có thể chạy bất kỳ mã khởi tạo nào trong` __init __. py` \) và sau đó import bất kỳ tên nào được định nghĩa trong gói. Điều này bao gồm bất kỳ tên được định nghĩa \ (và submodules được nạp một cách rõ ràng \) bởi `__init __. Py`. Nó cũng bao gồm bất kỳ mô-đun con nào của gói được tải một cách rõ ràng bằng các câu lệnh [`import`] (https://docs.python.org/3/reference/simple_stmts.html#import) trước đó. Hãy xem xét mã này:

`` `text
import sound.effects.echo
import sound.effects.surround
từ import sound.effects *
`` `

Trong ví dụ này, các mô đun `echo` và` surround` được nhập vào không gian tên hiện tại vì chúng được định nghĩa trong gói `sound.effects` khi câu lệnh` from ... import` được thi hành. \ (Điều này cũng hoạt động khi `` `` `` được xác định.\)

Mặc dù các mô-đun nhất định được thiết kế để chỉ xuất các tên theo một số mẫu nhất định khi bạn sử dụng `import *`, nó vẫn được coi là thực hành không tốt trong mã sản xuất.

Hãy nhớ rằng, không có gì sai khi sử dụng `từ gói Import specific_submodule`! Trong thực tế, đây là ký hiệu được đề nghị trừ khi mô-đun import cần sử dụng các mô-đun con có cùng tên từ các gói khác nhau.

#### 6.4.2. Intra-package Tài liệu tham khảo

Khi các gói được cấu trúc thành các gói con \ (như với gói `sound` trong ví dụ \), bạn có thể sử dụng import tuyệt đối để tham chiếu đến các mô-đun con của các gói anh chị em. Ví dụ, nếu module `sound.filters.vocoder` cần sử dụng mô-đun` echo` trong gói `sound.effects`, nó có thể sử dụng` fromsound.effects import echo`.

Bạn cũng có thể viết import tương đối, với dạng `from module import name` của câu lệnh import. Các mục nhập này sử dụng các dấu chấm đầu để chỉ ra các gói hiện tại và cha mẹ có liên quan đến việc nhập tương đối. Từ ví dụ `surround`module, bạn có thể sử dụng:

`` `text
từ . import echo
từ .. định dạng nhập
từ bộ cân bằng import ..filters
`` `

Lưu ý rằng import tương đối dựa trên tên của mô-đun hiện tại. Vì tên của mô-đun chính luôn là `" __main __ "`, các mô-đun được sử dụng làm mô đun chính của ứng dụng Python phải luôn sử dụng import tuyệt đối.

#### 6.4.3. Gói trong nhiều thư mục

Các gói hỗ trợ một thuộc tính đặc biệt hơn, [`__path__`] (https://docs.python.org/3/reference/import.html#__path__). Điều này được khởi tạo là một danh sách chứa tên của thư mục chứa `__init __. Py` của gói trước khi mã trong file đó được thi hành. Biến này có thể được sửa đổi; làm như vậy sẽ ảnh hưởng đến các tìm kiếm trong tương lai cho các mô-đun và các gói con chứa trong gói.

Mặc dù tính năng này thường không cần thiết, nhưng nó có thể được sử dụng để mở rộng tập các mô-đun được tìm thấy trong một gói.

Chú thích

| [\ [1 \]] (https://docs.python.org/3/tutorial/modules.html#id1) | Trong các định nghĩa chức năng thực tế cũng là 'các câu lệnh' được 'thi hành'; việc thực hiện định nghĩa hàm cấp mô-đun sẽ nhập tên hàm vào bảng ký hiệu toàn cục của mô-đun. |
| --- |